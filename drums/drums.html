<!DOCTYPE html>
<html>
  <head>
    <title>drums</title>
    <meta name="viewport" content="width=400">
    <script src="play.js"></script>
    <script src="song.js"></script>
    <script src="timeline.js"></script>
    <script src="lz-string-1.3.3.js"></script>
    <script src="base64-string-v1.1.0.js"></script>
    <script>

var context = new webkitAudioContext();
var master_verb = null;
var master_verb_gain = null;
var master_dry_gain = null;
var master_comp = null;
var master_meter = null;
var fx_channel = [];
var fx_time_trims = [];
var fx_adjust_function = {};
var fx_solo_channel = -1;

var sound_source = null;
var buffer = null;
var meter_update_functions = [];
var meter_timeout = -1;
var meter_pause_countup = 0;

var sounds = {};
var kit = null;
var song = null;

var play_state = null;

var nav_x = 0;
var nav_y = 5;
var NOTES_NAV_Y = 5;
var NOTES_MAX_NAV_X = 16;
var MAX_NAV_X = 10;
var MAX_NAV_Y = 14 + NOTES_NAV_Y;

var last_instrument = 0;

function loadfn(buffer, url, error_info) {
  if (buffer) {
    sounds[url] = buffer;
  }
}

function loadkit(instrument_list) {
  var kit = [];
  for (i in instrument_list) {
    var info_in = instrument_list[i];
    for (layer in info_in) {
      for (volume in info_in[layer]) {
        load_sample(info_in[layer][volume], loadfn);
      }
    }
    kit.push(info_in);
  }
  return kit;
}

function init() {
  buffer = context.createBuffer(2, 10000, 44100);

  // Test tone.
  sound_source = context.createBufferSource();
  sound_source.buffer = buffer;
  sound_source.connect(context.destination);
  var data = buffer.getChannelData(0);
  for (var i = 0; i < data.length; i++) {
    data[i] = Math.sin(i / data.length * 1000);
  }
  var data = buffer.getChannelData(1);
  for (var i = 0; i < data.length; i++) {
    data[i] = Math.sin(i / data.length * 1000 + 0.1);
  }
  sound_source.start(0);

  // Master fx etc.
  master_dry_gain = context.createGain();
  master_verb = context.createConvolver();
  master_verb_gain = context.createGain();
  master_comp = context.createDynamicsCompressor();
  master_meter = context.createAnalyser();

  master_dry_gain.connect(master_comp);
  master_verb.connect(master_verb_gain);
  master_verb_gain.connect(master_comp);
  master_comp.connect(context.destination);
  master_comp.connect(master_meter);

//   var delay1 = context.createDelay(0.020);
//   var delay2 = context.createDelay(0.020);
//   delay1.delayTime = 0.020;
//   delay2.delayTime = 0.020;
//   master_comp.connect(delay1);
//   delay1.connect(delay2);
//   delay1.connect(master_meter);
//   delay2.connect(master_meter);

  // http://www.openairlib.net/auralizationdb/content/stairway-university-york
  // http://www.openairlib.net/auralizationdb/content/maes-howe
  // http://www.openairlib.net/auralizationdb/content/terrys-typing-room
  // http://www.openairlib.net/auralizationdb/content/lady-chapel-st-albans-cathedral
  // cc-by-sa
//  load_sample(
//      //"samples/stairwell_ortf.wav",   // tight
//      //"samples/mh3_000_ortf_48k.wav",  // nice small room (vocal?)
//      //"samples/terrys_typing_ortf.wav",  // big, slap-back
//      "samples/lyd3_000_ortf_48k.wav",  //
//      //"samples/stalbans_a_binaural.wav",  // boomy, but boxy
//      function(buffer) {
//      master_verb.buffer = buffer;
//      });

  // http://www.echochamber.ch/index.php/tipps-a-freebies/impulseresponses
  // http://www.echochamber.ch/images/responses/quantec/quantec_1.ZIP
  load_sample(
      "samples/reverb/quantec_1/concert_h+a.wav",
      function(buffer) {
        master_verb.buffer = buffer;
      });

  master_verb_gain.gain.value = 0.30;
  master_dry_gain.gain.value = 2.0;

  master_comp.attack.value = 0.003;
  master_comp.knee.value = 30;
  master_comp.ratio.value = 4;
  master_comp.reduction.value = -0.000123;
  master_comp.release.value = 0.050;
  master_comp.threshold.value = -10;

  // fx channels
  var flat = context.createBuffer(2, 1, 44100);
  flat.getChannelData(0)[0] = 1;
  flat.getChannelData(1)[0] = 1;
  for (var i = 0; i < 9; i++) {
    var fx = {
      "trim": context.createGain(),
      "dry_gain": context.createGain(),
      "eqhi": context.createBiquadFilter(),
      "eqmid": context.createBiquadFilter(),
      "eqlo": context.createBiquadFilter(),
      "comp": context.createDynamicsCompressor(),
      "rev": context.createConvolver(),
      "fade": context.createGain(),
      "meter": context.createAnalyser(),
      "wet_gain": context.createGain(),
      "dry": { value: false },
      "solo": { value: false },
      "mute": { value: false },
    };
    fx.trim.connect(fx.eqhi);
    fx.trim.connect(fx.dry_gain);
    fx.dry_gain.connect(fx.fade);
    fx.eqhi.connect(fx.eqmid);
    fx.eqmid.connect(fx.eqlo);
    fx.eqlo.connect(fx.comp);
    fx.comp.connect(fx.rev);
    fx.rev.connect(fx.wet_gain);
    fx.wet_gain.connect(fx.fade);
    fx.fade.connect(fx.meter);
    fx.fade.connect(master_verb);
    fx.fade.connect(master_dry_gain);

    fx.dry_gain.gain.value = 0.0;
    fx.eqhi.type = "highshelf";
    fx.eqhi.frequency.value = 12000;
    fx.eqhi.gain.value = 0;
    fx.eqmid.type = "peaking";
    fx.eqmid.frequency.value = 2000;
    fx.eqmid.Q.value = 1.0;
    fx.eqmid.gain.value = 0;
    fx.eqlo.type = "lowshelf";
    fx.eqlo.frequency.value = 100;
    fx.eqlo.gain.value = 0;
    fx.comp.threshold.value = -10;
    fx.comp.ratio.value = 1;
    fx.comp.knee.value = 0;
    fx.rev.normalize = false;  // The f'ing normalization formula for convolver is bugged? sigh
    fx.rev.buffer = flat;
    fx.wet_gain.gain.value = 1.0;

    fx_channel.push(fx);

    fx_time_trims.push({ "value": 0 });
  }

  kit1 = loadkit([
      [["bender_stick.wav"]],
      [["builttospill_kick.wav"]],
      [["builttospill_ride.wav"]],
      [["gobo_hat.wav"]],
      [["gobo_hat2.wav"]],
      [["gobo_snare.wav"]],
      [["smokingpopes_kick.wav"]],
      [["spoon_hi_tom.wav"]],
      [["spoon_lo_tom.wav"]],
      [["spoon_snare.wav"]],
      [["stevenson_snare.wav"]],]
          );


  // 0: kick
  // 1: snare
  // 2: hat foot
  // 3: hat tight
  // 4: hat loose
  // 5: hat open
  // 6: ride
  // 7: small tom
  // 8: mid tom
  // 9: floor tom
  // 10: small crash
  // 11: large crash
  // 12: large china

  // http://rhythminmind.net/STN/?page_id=14
  kit = loadkit([
    [["samples/kick 1 combined - 22in pearl master custom.wav"],
     ["samples/kick 2 combined - 22in pearl master custom.wav"],
     ["samples/kick 3 combined - 22in pearl master custom.wav"],
     ["samples/kick 4 combined - 22in pearl master custom.wav"],
     ["samples/kick 5 combined - 22in pearl master custom.wav"],
     ["samples/kick 6 combined - 22in pearl master custom.wav"],
     ],
    [["samples/snare combined 1 - 14in pearl master custom.wav"],
     ["samples/snare combined 2 - 14in pearl master custom.wav"],
     ["samples/snare combined 3 - 14in pearl master custom.wav"],
     ["samples/snare combined 4 - 14in pearl master custom.wav"],
     ["samples/snare combined 5 - 14in pearl master custom.wav"],
     ["samples/snare combined 6 - 14in pearl master custom.wav"],
    ],
    [["samples/hat foot 1 - 13in zildjian remix.wav"],
     ["samples/hat foot 2 - 13in zildjian remix.wav"],
     ["samples/hat foot 3 - 13in zildjian remix.wav"],
    ],
    [["samples/hat tight 1 - 13in zildjian remix.wav"],
     ["samples/hat tight 2 - 13in zildjian remix.wav"],
     ["samples/hat tight 3 - 13in zildjian remix.wav"],
     ["samples/hat tight 4 - 13in zildjian remix.wav"],
     ["samples/hat tight 5 - 13in zildjian remix.wav"],
     ["samples/hat tight 6 - 13in zildjian remix.wav"],
     ],
    [["samples/hat loose 1 - 13in zildjian remix.wav"],
     ["samples/hat loose 2 - 13in zildjian remix.wav"],
     ["samples/hat loose 3 - 13in zildjian remix.wav"],
     ["samples/hat loose 4 - 13in zildjian remix.wav"],
     ["samples/hat loose 5 - 13in zildjian remix.wav"],
     ["samples/hat loose 6 - 13in zildjian remix.wav"],
    ],
    [["samples/hat open 1 - 13in zildjian remix.wav"],
     ["samples/hat open 2 - 13in zildjian remix.wav"],
     ["samples/hat open 3 - 13in zildjian remix.wav"],
     ["samples/hat open 4 - 13in zildjian remix.wav"],
    ],
    [["samples/ride 1 - 18in zildjian.wav"],
     ["samples/ride 2 - 18in zildjian.wav"],
     ["samples/ride 3 - 18in zildjian.wav"],
     ["samples/ride 4 - 18in zildjian.wav"],
     ["samples/ride 5 - 18in zildjian.wav"],
     ["samples/ride 6 - 18in zildjian.wav"],
    ],
    //[["samples/small crash 6 - 16in zildjian.wav"]],
    [["samples/small tom 1 - 10in pearl master custom.wav"],
     ["samples/small tom 2 - 10in pearl master custom.wav"],
     ["samples/small tom 3 - 10in pearl master custom.wav"],
     ["samples/small tom 4 - 10in pearl master custom.wav"],
     ["samples/small tom 5 - 10in pearl master custom.wav"],
     ["samples/small tom 6 - 10in pearl master custom.wav"],
    ],
    [["samples/med tom 1 - 12in pearl master custom.wav"],
     ["samples/med tom 2 - 12in pearl master custom.wav"],
     ["samples/med tom 3 - 12in pearl master custom.wav"],
     ["samples/med tom 4 - 12in pearl master custom.wav"],
     ["samples/med tom 5 - 12in pearl master custom.wav"],
     ["samples/med tom 6 - 12in pearl master custom.wav"],
    ],
    [["samples/floor tom 1 - 14in pearl master custom.wav"],
     ["samples/floor tom 2 - 14in pearl master custom.wav"],
     ["samples/floor tom 3 - 14in pearl master custom.wav"],
     ["samples/floor tom 4 - 14in pearl master custom.wav"],
     ["samples/floor tom 5 - 14in pearl master custom.wav"],
     ["samples/floor tom 6 - 14in pearl master custom.wav"],
    ],
    [["samples/small crash 1 - 16in zildjian.wav"],
     ["samples/small crash 2 - 16in zildjian.wav"],
     ["samples/small crash 3 - 16in zildjian.wav"],
     ["samples/small crash 4 - 16in zildjian.wav"],
     ["samples/small crash 5 - 16in zildjian.wav"],
     ["samples/small crash 6 - 16in zildjian.wav"],
     ],
    [["samples/large crash 1 - 18in zildjian.wav"],
     ["samples/large crash 2 - 18in zildjian.wav"],
     ["samples/large crash 3 - 18in zildjian.wav"],
     ["samples/large crash 4 - 18in zildjian.wav"],
     ["samples/large crash 5 - 18in zildjian.wav"],
     ["samples/large crash 6 - 18in zildjian.wav"],
     ],
    [["samples/large china 1 - 22in zildjian.wav"],
     ["samples/large china 2 - 22in zildjian.wav"],
     ["samples/large china 3 - 22in zildjian.wav"],
     ["samples/large china 4 - 22in zildjian.wav"],
     ["samples/large china 5 - 22in zildjian.wav"],
     ["samples/large china 6 - 22in zildjian.wav"],
     ],
                  ]);

  init_kit_fx_ui();
  update_from_location();
  init_timeline();
}

function keydown(ev) {
  if (ev.keyCode >= 48 && ev.keyCode <= 57) {  // '0' - '9'
    var instrument = ev.keyCode - 48;
    if (ev.shiftKey) {
      instrument += 10;
    }
    if (nav_y < NOTES_NAV_Y) {
      toggle_notes(instrument, nav_x, nav_y);
    }
    play(instrument, 255.0, 0.010);
    last_instrument = instrument;
    update_timeline_view();
  } else if (ev.keyCode == 32) {  // space
    toggle_play();
  } else if (ev.keyCode == 38) {  // up
    nav_up();
  } else if (ev.keyCode == 40) {  // down
    nav_down();
  } else if (ev.keyCode == 37) {  // left
    nav_left();
  } else if (ev.keyCode == 39) {  // right
    nav_right();
  } else if (ev.keyCode == 189) {  // -
    do_increment(-1, ev.shiftKey ? 1 : 0);
  } else if (ev.keyCode == 187) {  // +
    do_increment(1, ev.shiftKey ? 1 : 0);
  } else if (ev.keyCode == 219) {  // [
    loop_adjust(-1, ev.shiftKey ? -1 : 1);
  } else if (ev.keyCode == 221) {  // ]
    loop_adjust(1, ev.shiftKey ? -1 : 1);
  }

  // 189 == '-'
  // 187 == '=' (+)

  // 16 == shift
  // 17 == ctrl
  // 18 == alt

  // 219 == '[' and '{'
  // 221 == ']' and '}'

  //console.log(ev.keyCode);//xxxxxx
}

function toggle_play() {
  if (play_state) {
    if (play_state.playing) {
      stop_song();
      show_playing(false);
      return;
    } else if (play_state.song) {
      unpause();
      show_playing(true);
      return;
    }
  }
  start_song(song);
  show_playing(true);
}

function show_playing(playing) {
  var button = document.getElementById("play_button");
  if (playing) {
    button.innerHTML = "&#9646;&nbsp;&#9646;";
  } else {
    button.innerHTML = "&#9654;";
  }
}

function keyup(ev) {
}

function handle_unanchored() {
  if (document.activeElement == document.body ||
      document.activeElement.getAttribute("class") != "knob32anchor") {
    document.getElementById("fx0eqhi").previousSibling.focus();
    return true;
  }
  return false;
}

var fx_ids = [
  "dt",
  "trim",
  "eqhi",
  "eqmd",
  "eqsw",
  "eqlo",
  "c_thr",
  "c_rat",
  "c_att",
  "c_rel",
  "dry",
  "fade",
  "solo",
  "mute",
];

var master_fx_ids = [
  "dry",
  "rev",
  "c_thr",
  "c_rat",
  "c_att",
  "c_rel",
];

function fx_index_to_id(index) {
  var channel = (index >> 4);
  var i = index & 15;
  return nav_to_fx_id(channel, i + NOTES_NAV_Y);
}

function nav_to_fx_id(x, y) {
  if (x < 9 && y >= NOTES_NAV_Y && y < NOTES_NAV_Y + fx_ids.length) {
    // channel fx panel
    var yi = Math.min(y - NOTES_NAV_Y, fx_ids.length - 1);
    return id = "fx" + String(x) + fx_ids[yi];
  }
  if (x == 9 && y >= NOTES_NAV_Y) {
    // master fx panel
    var yi = Math.min(y - NOTES_NAV_Y, master_fx_ids.length - 1);
    return id = "fx10" + master_fx_ids[yi];
  }
  return '';
}

function focus_nav() {
  if (nav_y < 0) { nav_y = MAX_NAV_Y - 1; }
  if (nav_y >= MAX_NAV_Y) { nav_y = 0; }

  if (nav_y < NOTES_NAV_Y) {
    if (nav_x < 0) { nav_x = NOTES_MAX_NAV_X - 1; }
    if (nav_x >= NOTES_MAX_NAV_X) { nav_x = 0; }
  } else {
    if (nav_x < 0) { nav_x = MAX_NAV_X - 1; }
    if (nav_x >= MAX_NAV_X) { nav_x = 0; }
  }
  show_overlay();  // Update timeline nav.
  if (nav_y >= NOTES_NAV_Y) {
    // FX navigation
    var id = nav_to_fx_id(nav_x, nav_y);
    if (!id) {
      console.log("bad nav!", nav_x, nav_y);
      return;
    }
    var elem = document.getElementById(id);
    elem.previousSibling.focus();
  } else {
    // Some kind of blur.
  }
}

function nav_up() {
  nav_y--;
  focus_nav();
}

function nav_down() {
  nav_y++;
  focus_nav();
}

function nav_left() {
  nav_x--;
  focus_nav();
}

function nav_right() {
  nav_x++;
  focus_nav();
}

function do_increment(ticks, modifier) {
  focus_nav();
  if (nav_y < NOTES_NAV_Y) {
    adjust_notes(last_instrument, ticks, modifier, nav_x, nav_y);
  } else {
    // fx panel
    var id = nav_to_fx_id(nav_x, nav_y);
    if (id) {
      var adjust_fn = fx_adjust_function[id];
      if (adjust_fn) {
	var result = adjust_fn(ticks);
      }
    }
  }
}

var fx_channel_assignments = [
  [0, 7, 8],  // kick
  [1, 7, 8],  // snare
  [2, 7, 8],  // hat foot
  [2, 7, 8],  // hat tight
  [2, 7, 8],  // hat loose
  [2, 7, 8],  // hat open
  [3, 7, 8],  // ride
  [4, 7, 8],  // htom
  [5, 7, 8],  // mtom
  [6, 7, 8],  // ltom
  [7, 8],  // small crash
  [7, 8],  // large crash
  [7, 8],  // china crash
];

function play(instrument, volume, time) {
  var inst = kit[instrument];
  for (layer in inst) {
    var nl = inst[layer].length;
    var index = Math.floor(volume / 256.0 * nl);
    var url = inst[layer][index];
    var vol1 = Math.floor((index + 1) / nl * 255.0);
    var v = 255.0 * volume / vol1;
    var time_trim = fx_time_trims[fx_channel_assignments[instrument][0]].value;
    rawplay(url, v, time + time_trim, fx_channel_assignments[instrument]);
  }
}

function rawplay(url, volume, time, channels) {
  if (url in sounds) {
    var src = context.createBufferSource();
    src.buffer = sounds[url];
    var gain = context.createGain();
    gain.gain.value = volume / 255.0;
    for (i in channels) {
      var chan = channels[i];
      if (solo_channel < 0 || chan == solo_channel) {
	gain.connect(fx_channel[chan].trim);
      }
    }
    src.connect(gain);

    if (time == undefined) {
      time = context.currentTime + 0.010;
    }
    src.start(time);

    check_meters();
  }
}

function check_meters() {
  meter_pause_countup = 0;
  if (meter_timeout == -1) {
    meter_timeout = window.setTimeout(update_meters, 50);
  }
}

function update_meters() {
  meter_timeout = -1;
  meter_pause_countup++;

  for (var i = 0; i < meter_update_functions.length; i++) {
    meter_update_functions[i]();
  }

  if (meter_pause_countup < 80) {
    meter_timeout = window.setTimeout(update_meters, 50);
  }
}

function load_sample(url, continuation) {
  var request = new XMLHttpRequest();
  request.open("GET", url, true);
  request.responseType = "arraybuffer";

  request.onload = function() {
    context.decodeAudioData(request.response, function(buffer) {
        continuation(buffer, url, null);
      },
      function() {
        console.log("error loading", url);
      }
      );
  };
  request.onerror = function() {
    console.log("XHR loading error", url);
    continuation(null, url, "error");
  };
  request.send();
}

function update_dry(id, channel) {
  if (channel >= 0) {
    var fx = fx_channel[channel];
    if (fx.dry.value) {
      fx.dry_gain.gain.value = 1.0;
      fx.wet_gain.gain.value = 0.0;
    } else {
      fx.dry_gain.gain.value = 0.0;
      fx.wet_gain.gain.value = 1.0;
    }
  }
}

function update_solo_mute(id, channel) {
  // solo > mute
  // If any solos are pressed, connect them and disconnect others.
  // Only one solo channel allowed at a time.
  // Mute anything that's muted and not solo'd

  if (channel >= 0 && fx_channel[channel].solo.value) {
    solo_channel = channel;
    // Force any other solos off.
    for (var i = 0; i < fx_channel.length; i++) {
      if (i != channel) {
	if (fx_channel[i].solo.value) {
	  // Toggle it off.
	  fx_adjust_function["fx" + i + "solo"](-1);
	}
      }
    }
  }
  var any_solos = false;
  for (var i = 0; i < fx_channel.length; i++) {
    if (fx_channel[i].solo.value) {
      any_solos = true;
    }
  }
  if (!any_solos) {
    solo_channel = -1;
  }

  for (var i = 0; i < fx_channel.length; i++) {
    if ((solo_channel >= 0 && i != solo_channel) || fx_channel[i].mute.value) {
      // Mute.
      fx_channel[i].fade.disconnect(master_verb);
      fx_channel[i].fade.disconnect(master_dry_gain);
    } else {
      // Connect.
      fx_channel[i].fade.connect(fx_channel[i].meter);
      fx_channel[i].fade.connect(master_verb);
      fx_channel[i].fade.connect(master_dry_gain);
    }
  }
}

// kit ui

var knob_image_url;

function init_kit_fx_ui() {
  // Make a knob.
  var canvas = document.createElement('canvas');
  canvas.setAttribute("width", "32");
  canvas.setAttribute("height", "32");
  var ctx = canvas.getContext('2d');
  ctx.clearRect(0, 0, 32, 32);
  ctx.fillStyle = "#ddd";
  ctx.strokeStyle = "#000";
  ctx.lineWidth = 2.0;
  ctx.beginPath();
  ctx.arc(16.5, 16.5, 14, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(16.5, 16.5 - 8);
  ctx.lineTo(16.5, 2);
  ctx.stroke();
  knob_image_url = canvas.toDataURL();

  var styles = document.getElementById("styles").sheet;
  var rule = "position: absolute; top: 0; height: 32px; left: 0; width: 32px; background-image: url(" + knob_image_url + ");";
  styles.addRule(".knob32", rule);

  var channel_names = [ "kick", "snare", "hat", "ride",
                        "htom", "mtom", "ltom",
                        "OH", "room"
                         ];
  for (var i in channel_names) {
    document.getElementById("fx" + i).appendChild(make_channel_fx_ui(i, channel_names[i]));
  }
  document.getElementById("fxmaster").appendChild(make_master_fx_ui());
  for (var control in fx_adjust_function) {
    fx_adjust_function[control](0);
  }

  // Set default params...
  set_fx_settings(create_default_fx());
}

function create_default_fx() {
  return {
    "fx0eqmd": 9,
    "fx0eqsw": 16,
    "fx0eqlo": 16,
    "fx0c_thr": 29,
    "fx0c_rat": 15,
    "fx0c_att": 4,
    "fx0c_rel": 8,
    "fx1eqmd": 12,
    "fx1eqsw": 22,
    "fx1eqlo": 18,
    "fx1c_thr": 24,
    "fx1c_rat": 11,
    "fx1c_att": 4,
    "fx1c_rel": 8,
    "fx2fade": 5,
    "fx7fade": 4,
    "fx8fade": 4,
  };
}

function get_fx_settings() {
  var fx = {};
  for (var i = 0; i < 256; i++) {
    var id = fx_index_to_id(i);
    if (id) {
      var info = fx_adjust_function[id](0);
      var tick = info.tick;
      fx[id] = tick;
    }
  }
  return fx;
}

function set_fx_settings(params) {
  for (var p in params) {
    fx_adjust_function[p](-100);  // Set it to 0.
    fx_adjust_function[p](params[p]);  // Set the value.
  }
}

function make_channel_fx_ui(i, label) {
  var outer = document.createElement("div");
  outer.style.width = "34px";
  outer.innerHTML = label + "<br/>";
  outer.appendChild(make_knob_widget(i, "dt", fx_time_trims[i], -0.050, 0.050, 0));
  outer.appendChild(make_knob_widget(i, "trim", fx_channel[i].trim.gain, 0, 2, 1));
  outer.appendChild(make_knob_widget(i, "eqhi", fx_channel[i].eqhi.gain, -20, 20, 0));
  outer.appendChild(make_knob_widget(i, "eqmd", fx_channel[i].eqmid.gain, -20, 20, 0));
  outer.appendChild(make_knob_widget(i, "eqsw", fx_channel[i].eqmid.frequency, 200, 8000, 2000, 64, true));
  outer.appendChild(make_knob_widget(i, "eqlo", fx_channel[i].eqlo.gain, -20, 20, 0));

  outer.appendChild(make_knob_widget(i, "c_thr", fx_channel[i].comp.threshold, -100, 0, 0));
  outer.appendChild(make_knob_widget(i, "c_rat", fx_channel[i].comp.ratio, 1, 20, 2, undefined, true));
  outer.appendChild(make_knob_widget(i, "c_att", fx_channel[i].comp.attack, 0, 1, 0.100));
  outer.appendChild(make_knob_widget(i, "c_rel", fx_channel[i].comp.release, 0, 1, 0.250));

  //outer.appendChild(make_knob_widget(i, "_8", fx_channel[i].rev...));//xxxx TODO reverb

  outer.appendChild(make_toggle_widget(i, "dry", fx_channel[i].dry, "#cfc", "#0c0", false, update_dry));
  outer.appendChild(make_knob_widget(i, "fade", fx_channel[i].fade.gain, 0, 2, 1));

  outer.appendChild(make_toggle_widget(i, "solo", fx_channel[i].solo, "#ffc", "#ff0", false, update_solo_mute));
  outer.appendChild(make_toggle_widget(i, "mute", fx_channel[i].mute, "#fcc", "#f00", false, update_solo_mute));

  outer.appendChild(make_meter_widget(fx_channel[i].meter));

  return outer;
}

function make_master_fx_ui() {
  var outer = document.createElement("div");
  outer.style.width = "34px";
  outer.innerHTML = "master<br/>";
  outer.appendChild(make_knob_widget(10, "dry", master_dry_gain.gain, 0, 2, 1));
  outer.appendChild(make_knob_widget(10, "rev", master_verb_gain.gain, 0, 2, 0.30));
  outer.appendChild(make_knob_widget(10, "c_thr", master_comp.threshold, -100, 0, -10));
  outer.appendChild(make_knob_widget(10, "c_rat", master_comp.ratio, 1, 20, 4, undefined, true));
  outer.appendChild(make_knob_widget(10, "c_att", master_comp.attack, 0, 1, 0.003));
  outer.appendChild(make_knob_widget(10, "c_rel", master_comp.release, 0, 1, 0.050));

  outer.appendChild(make_meter_widget(master_meter));

  return outer;
}

function make_knob_widget(i, label, variable, lo, hi, def, opt_increments, opt_logscale) {
  var d = document.createElement("div");
  d.setAttribute("class", "control");
  var id = "fx" + i + label;
  d.innerHTML = "<div style='height: 32px; display: table-cell; vertical-align: " +
      "middle;'><a href='javascript:void(0);' class='knob32anchor'> </a>" +
      "<div class='knob32' id='" + id +
          "' style='height: 32px;'></div><p class='knoblabel'>" + label + "</p></div>";

  var increments = opt_increments || 32;
  var logscale = opt_logscale || false;
  if (logscale) {
    def = Math.log(def);
    lo = Math.log(lo);
    hi = Math.log(hi);
  }
  var default_tick = Math.round((def - lo) / (hi - lo) * increments);

  // hookup gauge "fx0eqhi" to the variable.value
  var adjust = function(increment) {
    var current_value = variable.value;
    if (logscale) {
      current_value = Math.log(current_value);
    }
    var current = Math.round((current_value - lo) / (hi - lo) * increments);
    var next_tick = Math.max(0, Math.min(current + increment, increments));
    var next_value = (next_tick / increments) * (hi - lo) + lo;
    if (logscale) {
      next_value = Math.exp(next_value);
    }
    variable.value = next_value;

    var rotation = "rotate(" + Math.round((next_tick - increments / 2) * (288.0 / increments)) + "deg)";
    var elem = document.getElementById(id);
    if (elem) {
      elem.style["-webkit-transform"] = rotation;
      elem.style["-moz-transform"] = rotation;
      elem.style["transform"] = rotation;
      // maybe adjust the color if the setting is off the default.
    }

    var retval = { "tick": next_tick, "value": next_value };
    return retval;
  }

  fx_adjust_function[id] = adjust;
  adjust(-1000);
  adjust(default_tick);

  return d;
}

function make_toggle_widget(i, label, variable, color_off, color_on, def, update_closure) {
  var d = document.createElement("div");
  d.setAttribute("class", "control");
  d.style.height = "16px";
  var id = "fx" + i + label;
  d.innerHTML = "<div style='height: 16px;'><a href='javascript:void(0);' class='toggle32anchor'> </a>" +
      "<div class='toggle32' id='" + id +
      "' style='height: 16px;'></div><p class='togglelabel'>" + label + "</p></div>";

  var adjust = function(increment) {
    var current_value = variable.value;
    var current = (current_value & 1) ? true : false;
    var next_value = ((current + increment) & 1) ? true : false;
    variable.value = next_value;

    var elem = document.getElementById(id);
    if (elem) {
      elem.style.backgroundColor = next_value ? color_on : color_off;
    }

    var retval = { "value": next_value, "tick": Number(next_value) };
    if (update_closure) update_closure(id, i);
    return retval;
  }

  fx_adjust_function[id] = adjust;
  if (adjust(0).value != def) {
    adjust(1);
  }

  return d;
}

function log2(x) {
  return Math.log(x) / Math.log(2);
}

function create_meter_gradient_image(doc) {
  var dummy_canvas = doc.createElement("canvas");
  dummy_canvas.width = 256;
  dummy_canvas.height = 1;
  var gc = dummy_canvas.getContext("2d");
  var gradient = gc.createLinearGradient(0, 0, 256, 0);
  gradient.addColorStop(0, "cyan");
  gradient.addColorStop(0.33, "green");
  gradient.addColorStop(0.67, "yellow");
  gradient.addColorStop(1, "red");
  gc.fillStyle = gradient;
  gc.fillRect(0, 0, 256, 1);
  return gc.getImageData(0, 0, 256, 1);
}

var meter_gradient_image = null;

function make_meter_widget(analyzer) {
  var d = document.createElement("div");
  d.setAttribute("class", "gauge32");
  d.style.height = "32px";
  d.innerHTML = "<canvas width='32' height='32'></canvas>";

  var FREQ_BINS = analyzer.frequencyBinCount;
  var TIME_BINS = analyzer.fftSize;
  analyzer.smoothingTimeConstant = 0;
  analyzer.minDecibels = -50;
  analyzer.maxDecibels = -10;
  var canvas = d.firstChild;
  var ctx = canvas.getContext("2d");
  ctx.fillStyle = "#000";
  ctx.fillRect(0, 0, 32, 32);

  var NBINS = 8;
  var freqdata = new Uint8Array(FREQ_BINS);
  var timedata = new Uint8Array(TIME_BINS);
  var SMOOTHING_TC = 0.50;
  var last_sums = new Float32Array(NBINS);
  var last_sums2 = new Float32Array(NBINS);
  var sums = new Float32Array(NBINS);
  var peak_avg = new Float32Array(NBINS);
  var counts = new Array(NBINS);
  var peak = 0;

  // Make a gradient.
  if (!meter_gradient_image) {
    meter_gradient_image = create_meter_gradient_image(document);
  }

  var update = function() {
    analyzer.getByteFrequencyData(freqdata);
    for (var i = 0; i < NBINS; i++) {
      sums[i] = 0;
      counts[i] = 0;
    }
    for (var i = 1; i < freqdata.length; i++) {
      var bin = Math.floor((Math.log(i) - Math.log(1)) /
	  (Math.log(freqdata.length) - Math.log(1)) * NBINS);
      sums[bin] += freqdata[i];
      counts[bin]++;
    }
    for (var i = 0; i < NBINS; i++) {
      var avg = (sums[i] + last_sums[i] + last_sums2[i]) / counts[i] / 256.0 / 3.0;
      last_sums2[i] = last_sums[i];
      last_sums[i] = sums[i];

      if (avg > peak_avg[i]) {
        peak_avg[i] = avg;
      } else {
        peak_avg[i] = peak_avg[i] * (SMOOTHING_TC) + avg * (1 - SMOOTHING_TC);
      }
    }

    analyzer.getByteTimeDomainData(timedata);
    // Detect the waveform peak value in this frame (new_peak), and
    // also a smoothed version that tracks new peaks but decays over
    // time (peak).
    var new_peak = 0;
    for (var i = 0; i < timedata.length; i++) {
      var new_peak = Math.max(new_peak, Math.abs(timedata[i] - 128));
    }
    if (peak < new_peak) {
      peak = new_peak;
    } else {
      var PEAK_TC = 0.10;
      peak = peak * PEAK_TC + new_peak * (1 - PEAK_TC);
    }

    // Clear the canvas with partial transparency, so it fades over
    // time (i.e. for some motion blur).
    ctx.fillStyle = "rgba(0, 0, 0, 0.4)";
    ctx.fillRect(0, 0, 32, 32);

    // Peak bar.
    var smoothed_peak_y = 32 - peak / 128 * 32.0;
    var peak_y = 32 - new_peak / 128 * 32.0;
    var i = Math.min(Math.round((31 - smoothed_peak_y) / 32 * 255), 255);
    var r = meter_gradient_image.data[i * 4 + 0];
    var g = meter_gradient_image.data[i * 4 + 1];
    var b = meter_gradient_image.data[i * 4 + 2];
    var a = 0.25 * i / 255.0 + 0.75;
    ctx.fillStyle = "rgba(" + r + ", " + g + ", " + b + ", " + a + ")";
    ctx.fillRect(0, smoothed_peak_y, 32, 32);
    ctx.clearRect(0, peak_y, 32, 1);

    ctx.fillStyle = "rgba(255, 255, 255, 0.25)";
    for (var i = 0; i < NBINS; i++) {
      var avg = peak_avg[i];
      var fast_y = 32 - avg * 32.0;
      ctx.clearRect(i * 32 / NBINS, fast_y, 32 / NBINS, 32 - fast_y);
      ctx.fillRect(i * 32 / NBINS, fast_y, 32 / NBINS, 32 - fast_y);
    }

  }

  meter_update_functions.push(update);

  return d;
}

window.onload = init;
window.onkeydown = keydown;
window.onkeyup = keyup;

    </script>
    <style type="text/css" id="styles">
      .control {
        //margin-left: auto;
        //margin-right: 0px;
        //float: right;
        position: relative;
        width: 34px;
        height: 38px;
      }
      .gauge32 {
        height: 32px;
        width: 32px;
        background-size: 8px 32px;
        background-position: bottom;
        //background-image: linear-gradient(to top, blue, cyan, green, yellow, red);
        background-image: linear-gradient(to top, cyan, green, yellow, red);
      }
      .knoblabel {
        width: 32px;
        position: relative;
        font-size: 10px;
        font-family: sans-serif;
        text-align: center;
        margin-left: auto;
        margin-right: auto;
      }
      .knob32anchor {
        position: absolute;
        width: 32px;
        height: 32px;
      }
      .knob32anchor:focus {
        //background-color: yellow;
        border: 2px solid yellow;
      }
      .togglelabel {
        width: 32px;
        position: relative;
        font-size: 10px;
        font-family: sans-serif;
        text-align: center;
        margin-left: auto;
        margin-right: auto;
      }

      .toggle32 {
        position: absolute;
        width: 32px;
        height: 16px;
      }
      .toggle32anchor {
        position: absolute;
        width: 32px;
        height: 16px;
      }
      .toggle32anchor:focus {
        border: 2px solid yellow;
      }
    </style>
  </head>
  <body>

    <div id="timeline" style="height: 200px; width: 400px;">
      <canvas id="timeline_canvas" width="400" height="200" style="position:absolute;"></canvas>
      <canvas id="timeline_overlay_canvas" width="400" height="200" style="position:absolute;"></canvas>
    </div>

    <table id="kitparams" style="height: 400px;">
      <tr valign="top">
        <td id="fx0">
        </td><td id="fx1">
        </td><td id="fx2">
        </td><td id="fx3">
        </td><td id="fx4">
        </td><td id="fx5">
        </td><td id="fx6">
        </td><td id="fx7">
        </td><td id="fx8">
	</td><td width=10><!-- spacer --></td>
        <td id="fxmaster">
        </td>
        <td><button id="play_button" onclick="toggle_play()">&#9654;</button></td>
      </tr>
    </table>
  </body>
</html>
